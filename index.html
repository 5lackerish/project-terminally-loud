<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Modular 3D Character - Babylon.js</title>
<style>
html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; }
canvas { width: 100%; height: 100%; display: block; }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<!-- Babylon.js CDN -->
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/cannon.js"></script>

<script>
window.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.6, 0.8, 1);

    // Physics
    scene.enablePhysics(new BABYLON.Vector3(0,-9.81,0), new BABYLON.CannonJSPlugin());

    // Camera
    const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0,5,-10), scene);
    camera.attachControl(canvas, true);
    camera.speed = 0.5;

    // Lights
    const hemiLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
    hemiLight.intensity = 0.6;
    const dirLight = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1,-2,-1), scene);
    dirLight.position = new BABYLON.Vector3(20,40,20);
    dirLight.intensity = 0.8;

    // Ground
    const ground = BABYLON.MeshBuilder.CreateGround("ground",{width:50,height:50},scene);
    ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor,{mass:0,restitution:0.1},scene);

    // Modular character
    const root = new BABYLON.TransformNode("root",scene);
    root.position = new BABYLON.Vector3(0,2,0);

    const torso = BABYLON.MeshBuilder.CreateBox("torso",{height:2,width:1,depth:0.5},scene);
    torso.parent = root; torso.position.y=1;

    const head = BABYLON.MeshBuilder.CreateSphere("head",{diameter:0.8},scene);
    head.parent = root; head.position.y=2.5;

    const leftArm = BABYLON.MeshBuilder.CreateBox("leftArm",{height:1.5,width:0.3,depth:0.3},scene);
    leftArm.parent = root; leftArm.position.set(-0.8,1.25,0);
    const rightArm = BABYLON.MeshBuilder.CreateBox("rightArm",{height:1.5,width:0.3,depth:0.3},scene);
    rightArm.parent = root; rightArm.position.set(0.8,1.25,0);

    const leftLeg = BABYLON.MeshBuilder.CreateBox("leftLeg",{height:1.5,width:0.4,depth:0.4},scene);
    leftLeg.parent = root; leftLeg.position.set(-0.3,-0.75,0);
    const rightLeg = BABYLON.MeshBuilder.CreateBox("rightLeg",{height:1.5,width:0.4,depth:0.4},scene);
    rightLeg.parent = root; rightLeg.position.set(0.3,-0.75,0);

    root.physicsImpostor = new BABYLON.PhysicsImpostor(root, BABYLON.PhysicsImpostor.BoxImpostor,{mass:1, restitution:0, friction:0.5},scene);

    // Input
    const inputMap = {};
    scene.actionManager = new BABYLON.ActionManager(scene);
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, evt=>{inputMap[evt.sourceEvent.key.toLowerCase()]=true;}));
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, evt=>{inputMap[evt.sourceEvent.key.toLowerCase()]=false;}));

    let isPointerDown=false;
    canvas.addEventListener("pointerdown",()=>isPointerDown=true);
    canvas.addEventListener("pointerup",()=>isPointerDown=false);
    scene.onPointerObservable.add((pi)=>{
        if(!isPointerDown) return;
        const e=pi.event;
        camera.rotation.y+=e.movementX*0.002;
        camera.rotation.x+=e.movementY*0.002;
    },BABYLON.PointerEventTypes.POINTERMOVE);

    const speed = 0.15;
    const jumpForce = 5;
    let canJump=true;

    scene.onBeforeRenderObservable.add(()=>{
        // Horizontal movement vectors
        const camForward = new BABYLON.Vector3(camera.getDirection(BABYLON.Axis.Z).x,0,camera.getDirection(BABYLON.Axis.Z).z).normalize();
        const camRight = new BABYLON.Vector3(camera.getDirection(BABYLON.Axis.X).x,0,camera.getDirection(BABYLON.Axis.X).z).normalize();

        let moveDir = new BABYLON.Vector3(0,0,0);
        if(inputMap["w"]) moveDir.addInPlace(camForward);
        if(inputMap["s"]) moveDir.subtractInPlace(camForward);
        if(inputMap["a"]) moveDir.subtractInPlace(camRight);
        if(inputMap["d"]) moveDir.addInPlace(camRight);

        moveDir.normalize();

        // Smooth velocity
        const vel = root.physicsImpostor.getLinearVelocity();
        const targetVel = moveDir.scale(speed*60);
        const smoothVel = BABYLON.Vector3.Lerp(new BABYLON.Vector3(vel.x,0,vel.z), targetVel, 0.2);
        root.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(smoothVel.x, vel.y, smoothVel.z));

        // Jump
        if(inputMap[" "] && canJump){
            root.physicsImpostor.applyImpulse(new BABYLON.Vector3(0,jumpForce,0), root.getAbsolutePosition());
            canJump=false;
        }

        // Ground check
        if(root.position.y<=2.01) canJump=true;

        // Rotate character towards movement
        if(moveDir.length()>0){
            const angle=Math.atan2(moveDir.x, moveDir.z);
            root.rotation.y = BABYLON.Scalar.LerpAngle(root.rotation.y, angle, 0.2);
        }

        // Independent limb rotation
        const t = performance.now()*0.002;
        leftArm.rotation.x=Math.sin(t)*0.5;
        rightArm.rotation.x=-Math.sin(t)*0.5;
        leftLeg.rotation.x=Math.sin(t*0.5)*0.3;
        rightLeg.rotation.x=-Math.sin(t*0.5)*0.3;
        head.rotation.y=Math.sin(t*0.3)*0.5;
    });

    engine.runRenderLoop(()=>scene.render());
    window.addEventListener("resize",()=>engine.resize());
});
</script>
</body>
</html>
